<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8";/>
		<link href="css/style.css" rel="stylesheet" type="text/css" media="all" />
		<link href="css/cpp.css" rel="stylesheet" type="text/css" media="all" />
		<title>Wonroot</title>
	</head>
	<body>
		<div class="header">
			<div class="logo">
				<a href="index.html">
					<img src="image/logo.png" />
				</a>
			</div>
			<div class="menu">
				<ul>
					<li><a href="index.html">Home</a></li>

					<li><a href="#">Project</a>
						<ul>
							<li><a href="#">C++</a></li>
							<li><a href="#">数据库</a></li>
							<li><a href="#">数据结构</a></li>
						</ul>
					</li>

					<li><a href="#">About Me</a>
						<ul>
							<li><a href="#">Gtihub</a></li>
							<li><a href="#">Codding</a></li>
						</ul>
					</li>

				</ul>

			</div>
		</div>

		<div class="header-bottom">
			<a><span>数据结构课设一（单列表）</span></a>
		</div>



		<div class="text">
			<div class="text-contain">
				图的遍历</br>
				
			</div>

			<div class="text-contain text-header">
				<a><span>程序代码如下<span></a>
			</div>
			<pre>
				<code>
	
			
	
#include &lt;stdio.h>
#include &lt;stdlib.h>
	
#define MaxVertexNum 5
#define m 5
#define FALSE 0
#define TRUE 1

typedef struct node {
	int adjvex;
	struct node *next;
} JD;
typedef struct tnode {
	int vexdata;
	JD *firstarc;
} TD;
typedef struct {
	TD ag[m];
	int n;
} ALGraph;

int visited[MaxVertexNum]; //访问标志向量是全局量

void DFS(ALGraph *G, int i) {
//以vi为出发点对邻接表表示的图G进行深度优先搜索
	JD *p;
	printf("visit vertex:%d\n", G->ag[i].vexdata); //访问顶点vi
	visited[i] = TRUE; //标记vi已访问
	p = G->ag[i].firstarc; //取vi边表的头指针
	while (p) { //依次搜索vi的邻接点vi，这里j=p->adjvex
		if (!visited[p->adjvex]) //若vi尚未被访问
			DFS(G, p->adjvex); //则以Vj为出发点向纵深搜索
		p = p->next; //找vi的下一邻接点
	}
} //DFS

void DFSTraverse(ALGraph *G) { //深度优先遍历以邻接表表示的图G，而以邻接矩阵表示G时，算法完全与此相同
	int i;
	for (i = 0; i < G->n; i++)
		visited[i] = FALSE; //标志向量初始化
	for (i = 0; i < G->n; i++)
		if (!visited[i]) //vi未访问过
			DFS(G, i); //以vi为源点开始DFS搜索
} //DFSTraverse

void creat(ALGraph *G) {
	int i, m1, j;
	JD *p, *p1;
	printf("please input the number of graph:");
	scanf("%d", &G->n);
	for (i = 0; i < G->n; i++) {
		printf("please input the info of node %d:", i);
		scanf("%d", &G->ag[i].vexdata);
		printf("please input the number of arcs which adj to %d:", i);
		scanf("%d", &m1);
		printf("please input the adjvex position of the first arc:");
		p = (JD *) malloc(sizeof(JD));
		scanf("%d", &p->adjvex);
		p->next = NULL;
		G->ag[i].firstarc = p;
		p1 = p;
		for (j = 2; j <= m1; j++) {
			printf("please input the position of the next arc vexdata:");
			p = (JD *) malloc(sizeof(JD));
			if (!p)
				exit(0);
			scanf("%d", &p->adjvex);
			p->next = NULL;
			p1->next = p;
			p1 = p;
		}
	}
}

int main() {
	setbuf(stdout, NULL);
	ALGraph *G = (ALGraph*) malloc(sizeof(ALGraph));
	if (!G)
		exit(0);
	printf("下面以临接表存储一个图:\n");
	creat(G);
	printf("下面以深度优先遍历该图:\n");
	DFSTraverse(G);
	return 0;
}




				</code>
			</pre>



























		<div class="bottom">
			<div class="copyright">
				<a>©2016 TAOROOT</a>
				<p>本网站<span>（www.Wonroot.com）</span>刊载的所有内容，包括文字、图片、音频、视频、软件、程序、以及网页版式设计等均在网上搜集。<br/>
				  访问者可将本网站提供的内容或服务用于个人学习、研究或欣赏，以及其他非商业性或非盈利性用途，但同时应遵守著作权法及其他相关法律的规定，不得侵犯本网站及相关权利人的合法权利。<br/>
				  除此以外，将本网站任何内容或服务用于其他用途时，须征得本网站及相关权利人的书面许可，并支付报酬。<br/>
				    本网站内容原作者如不愿意在本网站刊登内容，请及时通知本站，予以删除。
				</p>
			<div>
		</div>

	</body>
</html>








